"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.subscribeToDocumentChanges = exports.refreshDiagnostics = exports.Emojinfo = exports.Emojizer = exports.activate = exports.EMOJI_MENTION = void 0;
const vscode = require("vscode");
//fetch connection to api
const node_fetch_1 = require("node-fetch");
/** Code that is used to associate diagnostic entries with code actions. */
exports.EMOJI_MENTION = 'emoji_mention';
/** String to detect in the text document. */
// eslint-disable-next-line prefer-const
let diagnosticLibrary = [
    { "vulnName": "Cross-Site", "vulnTitle": "Cross-Site vulnerability founded", "vulnSolution": "No cross-site" },
    { "vulnName": "Injection", "vulnTitle": "Injection vulnerability founded", "vulnSolution": "No injection" }
];
let diagnosticLibraryAPI;
// eslint-disable-next-line prefer-const
let solutionsLibrary = [];
const COMMAND = 'code-actions-sample.command';
function activate(context) {
    async function getUsers() {
        try {
            const response = await (0, node_fetch_1.default)('http://127.0.0.1:4000/data', {
                method: 'GET',
                headers: {
                    Accept: 'application/json',
                },
            });
            if (!response.ok) {
                throw new Error(`Error! status: ${response.status}`);
            }
            const result = (await response.json());
            /* 			console.log(result);
                        console.log('size: ', result.length);
                        console.log("Name: ", JSON.stringify(result[0].vulnName)); */
            diagnosticLibraryAPI = result;
            /* 			console.log('Size of diagn', JSON.stringify(diagnosticLibraryAPI[0].vulnName)); */
            return result;
        }
        catch (error) {
            if (error instanceof Error) {
                console.log('error message: ', error.message);
                return error.message;
            }
            else {
                console.log('unexpected error: ', error);
                return 'An unexpected error occurred';
            }
        }
    }
    const activeEditor = vscode.window.activeTextEditor;
    if (activeEditor) {
        const filePath = activeEditor.document.uri.fsPath;
        (0, node_fetch_1.default)('http://127.0.0.1:4000/path', {
            method: 'POST',
            body: JSON.stringify({ filePath }),
            headers: { 'Content-Type': 'application/json' },
        });
    }
    else {
        console.log('There is no active text editor');
    }
    getUsers();
    context.subscriptions.push(vscode.languages.registerCodeActionsProvider('javascript', new Emojizer(), {
        providedCodeActionKinds: Emojizer.providedCodeActionKinds
    }));
    const emojiDiagnostics = vscode.languages.createDiagnosticCollection("emoji");
    context.subscriptions.push(emojiDiagnostics);
    subscribeToDocumentChanges(context, emojiDiagnostics);
    context.subscriptions.push(vscode.languages.registerCodeActionsProvider('javascript', new Emojinfo(), {
        providedCodeActionKinds: Emojinfo.providedCodeActionKinds
    }));
    context.subscriptions.push(vscode.commands.registerCommand(COMMAND, () => vscode.env.openExternal(vscode.Uri.parse('https://security.snyk.io/vuln/SNYK-JS-SCULLYIOSCULLY-1055829'))));
}
exports.activate = activate;
/**
 * Provides code actions for converting :) to a smiley emoji.
 */
class Emojizer {
    provideCodeActions(document, range) {
        const vulnFindedName = this.whatIsOnLineAPI(document, range);
        if (vulnFindedName === -1) {
            return;
        }
        const replaceWithSmileyFix = this.createFix(document, range, JSON.stringify(diagnosticLibraryAPI[vulnFindedName].vulnSolution));
        // Marking a single fix as `preferred` means that users can apply it with a
        // single keyboard shortcut using the `Auto Fix` command.
        replaceWithSmileyFix.isPreferred = true;
        return [
            replaceWithSmileyFix,
        ];
    }
    isAtStartOfSmiley(document, range) {
        const start = range.start;
        const line = document.lineAt(start.line);
        return line.text.includes(diagnosticLibrary[1].vulnName);
    }
    whatIsOnLine(document, range) {
        const start = range.start;
        const line = document.lineAt(start.line);
        for (let i = 0; i < diagnosticLibrary.length; i++) {
            // eslint-disable-next-line prefer-const
            let vulName = diagnosticLibrary[i].vulnName;
            if (line.text.includes(vulName)) {
                return i;
            }
        }
        return -1;
    }
    whatIsOnLineAPI(document, range) {
        const start = range.start;
        const line = document.lineAt(start.line);
        for (let i = 0; i < diagnosticLibraryAPI.length; i++) {
            // eslint-disable-next-line prefer-const
            let vulName = JSON.stringify(diagnosticLibraryAPI[i].vulnName);
            if (line.text.includes(vulName)) {
                return i;
            }
        }
        return -1;
    }
    createFix(document, range, emoji) {
        const fix = new vscode.CodeAction(`Convert to ${emoji}`, vscode.CodeActionKind.QuickFix);
        fix.edit = new vscode.WorkspaceEdit();
        fix.edit.replace(document.uri, new vscode.Range(range.start, range.start.translate(0, 2)), emoji);
        return fix;
    }
}
exports.Emojizer = Emojizer;
Emojizer.providedCodeActionKinds = [
    vscode.CodeActionKind.QuickFix
];
/*
* -------------------------------------------------------------------------------------------------------------------------------------
* -------------------------------------------------------------------------------------------------------------------------------------
* -------------------------------------------------------------------------------------------------------------------------------------
* -------------------------------------------------------------------------------------------------------------------------------------
* -------------------------------------------------------------------------------------------------------------------------------------
* -------------------------------------------------------------------------------------------------------------------------------------
* -------------------------------------------------------------------------------------------------------------------------------------
* -------------------------------------------------------------------------------------------------------------------------------------
* -------------------------------------------------------------------------------------------------------------------------------------
* -------------------------------------------------------------------------------------------------------------------------------------
*/
/**
 * Provides code actions corresponding to diagnostic problems.
 */
class Emojinfo {
    provideCodeActions(document, range, context, token) {
        return context.diagnostics
            .filter(diagnostic => diagnostic.code === exports.EMOJI_MENTION)
            .map(diagnostic => this.createCommandCodeAction(diagnostic));
    }
    isAVulnerability(document, range, i) {
        const start = range.start;
        const line = document.lineAt(start.line);
        return line.text.includes(JSON.stringify(diagnosticLibraryAPI[i].vulnName));
    }
    createCommandCodeAction(diagnostic) {
        const action = new vscode.CodeAction('Vulnerability found', vscode.CodeActionKind.QuickFix);
        action.command = { command: COMMAND, title: 'Show vulnerabilities', tooltip: 'This will open the cross site scripting page' };
        action.diagnostics = [diagnostic];
        action.isPreferred = true;
        return action;
    }
    createFix(document, range, solution) {
        const fix = new vscode.CodeAction(`Replace with ${solution}`, vscode.CodeActionKind.QuickFix);
        fix.edit = new vscode.WorkspaceEdit();
        fix.edit.replace(document.uri, new vscode.Range(range.start, range.start.translate(0, 2)), solution);
        return fix;
    }
}
exports.Emojinfo = Emojinfo;
Emojinfo.providedCodeActionKinds = [
    vscode.CodeActionKind.QuickFix
];
/**
 * Analyzes the text document for problems.
 * This demo diagnostic problem provider finds all mentions of 'emoji'.
 * @param doc text document to analyze
 * @param emojiDiagnostics diagnostic collection
 */
function refreshDiagnostics(doc, emojiDiagnostics) {
    const diagnostics = [];
    for (let lineIndex = 0; lineIndex < doc.lineCount; lineIndex++) {
        const lineOfText = doc.lineAt(lineIndex);
        for (let i = 0; i < diagnosticLibraryAPI.length; i++) {
            if (lineOfText.text.includes(JSON.stringify(diagnosticLibraryAPI[i].vulnName))) {
                diagnostics.push(createDiagnostic(doc, lineOfText, lineIndex, i));
            }
        }
    }
    emojiDiagnostics.set(doc.uri, diagnostics);
}
exports.refreshDiagnostics = refreshDiagnostics;
function createDiagnostic(doc, lineOfText, lineIndex, i) {
    // find where in the line of that the 'emoji' is mentioned
    const index = lineOfText.text.indexOf(JSON.stringify(diagnosticLibraryAPI[i].vulnName));
    console.log("Soy el console log 10000 :D" + JSON.stringify(diagnosticLibraryAPI[i].vulnName).length);
    // create range that represents, where in the document the word is
    const range = new vscode.Range(lineIndex, index, lineIndex, index + JSON.stringify(diagnosticLibraryAPI[i].vulnName).length);
    const diagnostic = new vscode.Diagnostic(range, JSON.stringify(diagnosticLibraryAPI[i].vulnTitle), vscode.DiagnosticSeverity.Warning);
    diagnostic.code = exports.EMOJI_MENTION;
    return diagnostic;
}
function subscribeToDocumentChanges(context, emojiDiagnostics) {
    if (vscode.window.activeTextEditor) {
        refreshDiagnostics(vscode.window.activeTextEditor.document, emojiDiagnostics);
    }
    context.subscriptions.push(vscode.window.onDidChangeActiveTextEditor(editor => {
        if (editor) {
            refreshDiagnostics(editor.document, emojiDiagnostics);
        }
    }));
    context.subscriptions.push(vscode.workspace.onDidChangeTextDocument(e => refreshDiagnostics(e.document, emojiDiagnostics)));
    context.subscriptions.push(vscode.workspace.onDidCloseTextDocument(doc => emojiDiagnostics.delete(doc.uri)));
}
exports.subscribeToDocumentChanges = subscribeToDocumentChanges;
//# sourceMappingURL=extension.js.map