import * as vscode from 'vscode';
//fetch connection to api
import fetch from 'node-fetch';
/** Code that is used to associate diagnostic entries with code actions. */
export const EMOJI_MENTION = 'emoji_mention';

/** String to detect in the text document. */
// eslint-disable-next-line prefer-const
let diagnosticLibrary: { vulnName: string, vulnTitle: string, vulnSolution: string }[] = [
	{ "vulnName": "Cross-Site", "vulnTitle": "Cross-Site vulnerability founded", "vulnSolution": "No cross-site" },
	{ "vulnName": "Injection", "vulnTitle": "Injection vulnerability founded", "vulnSolution": "No injection" }
];
let diagnosticLibraryAPI: { vulnName: string, vulnTitle: string, vulnSolution: string }[];
type Data = {
	vulnName: string;
	vulnTitle: string;
	vulnSolution?: string;
};
type GetVulnsResponse = {
	data: Data[];
};

// eslint-disable-next-line prefer-const
let solutionsLibrary: vscode.CodeAction[] = [
];
const COMMAND = 'code-actions-sample.command';

export function activate(context: vscode.ExtensionContext) {
	async function getUsers() {
		try {
			const response = await fetch('http://127.0.0.1:4000/data', {
				method: 'GET',
				headers: {
					Accept: 'application/json',
				},
			});

			if (!response.ok) {
				throw new Error(`Error! status: ${response.status}`);
			}

			const result = (await response.json());
/* 			console.log(result);
			console.log('size: ', result.length);
			console.log("Name: ", JSON.stringify(result[0].vulnName)); */

			diagnosticLibraryAPI = result;
/* 			console.log('Size of diagn', JSON.stringify(diagnosticLibraryAPI[0].vulnName)); */
			return result;
		} catch (error) {
			if (error instanceof Error) {
				console.log('error message: ', error.message);
				return error.message;
			} else {
				console.log('unexpected error: ', error);
				return 'An unexpected error occurred';
			}
		}
	}

	const activeEditor = vscode.window.activeTextEditor;
	if (activeEditor) {
		const filePath = activeEditor.document.uri.fsPath;
		fetch('http://127.0.0.1:4000/path', {
			method: 'POST',
			body: JSON.stringify({ filePath }),
			headers: { 'Content-Type': 'application/json' },
		});
	} else {
		console.log('There is no active text editor');
	}

	getUsers();

	context.subscriptions.push(
		vscode.languages.registerCodeActionsProvider('javascript', new Emojizer(), {
			providedCodeActionKinds: Emojizer.providedCodeActionKinds
		}));

	const emojiDiagnostics = vscode.languages.createDiagnosticCollection("emoji");
	context.subscriptions.push(emojiDiagnostics);

	subscribeToDocumentChanges(context, emojiDiagnostics);

	context.subscriptions.push(
		vscode.languages.registerCodeActionsProvider('javascript', new Emojinfo(), {
			providedCodeActionKinds: Emojinfo.providedCodeActionKinds
		})
	);

	context.subscriptions.push(
		vscode.commands.registerCommand(COMMAND, () => vscode.env.openExternal(vscode.Uri.parse('https://security.snyk.io/vuln/SNYK-JS-SCULLYIOSCULLY-1055829')))
	);
}

/**
 * Provides code actions for converting :) to a smiley emoji.
 */
export class Emojizer implements vscode.CodeActionProvider {

	public static readonly providedCodeActionKinds = [
		vscode.CodeActionKind.QuickFix
	];

	public provideCodeActions(document: vscode.TextDocument, range: vscode.Range): vscode.CodeAction[] | undefined {

		const vulnFindedName = this.whatIsOnLineAPI(document, range);
		if (vulnFindedName === -1) {
			return;
		}

		const replaceWithSmileyFix = this.createFix(document, range, JSON.stringify(diagnosticLibraryAPI[vulnFindedName].vulnSolution));
		// Marking a single fix as `preferred` means that users can apply it with a
		// single keyboard shortcut using the `Auto Fix` command.
		replaceWithSmileyFix.isPreferred = true;

		return [
			replaceWithSmileyFix,
		];
	}

	private isAtStartOfSmiley(document: vscode.TextDocument, range: vscode.Range) {
		const start = range.start;
		const line = document.lineAt(start.line);

		return line.text.includes(diagnosticLibrary[1].vulnName);

	}
	private whatIsOnLine(document: vscode.TextDocument, range: vscode.Range): number {
		const start = range.start;
		const line = document.lineAt(start.line);

		for (let i = 0; i < diagnosticLibrary.length; i++) {
			// eslint-disable-next-line prefer-const
			let vulName = diagnosticLibrary[i].vulnName;
			if (line.text.includes(vulName)) {
				return i;
			}

		}

		return -1;
	}
	private whatIsOnLineAPI(document: vscode.TextDocument, range: vscode.Range): number {
		const start = range.start;
		const line = document.lineAt(start.line);

		for (let i = 0; i < diagnosticLibraryAPI.length; i++) {
			// eslint-disable-next-line prefer-const
			let vulName = JSON.stringify(diagnosticLibraryAPI[i].vulnName);
			if (line.text.includes(vulName)) {
				return i;
			}

		}

		return -1;
	}

	private createFix(document: vscode.TextDocument, range: vscode.Range, emoji: string): vscode.CodeAction {
		const fix = new vscode.CodeAction(`Convert to ${emoji}`, vscode.CodeActionKind.QuickFix);
		fix.edit = new vscode.WorkspaceEdit();
		fix.edit.replace(document.uri, new vscode.Range(range.start, range.start.translate(0, 2)), emoji);
		return fix;
	}
}



/* 
* -------------------------------------------------------------------------------------------------------------------------------------
* -------------------------------------------------------------------------------------------------------------------------------------
* -------------------------------------------------------------------------------------------------------------------------------------
* -------------------------------------------------------------------------------------------------------------------------------------
* -------------------------------------------------------------------------------------------------------------------------------------
* -------------------------------------------------------------------------------------------------------------------------------------
* -------------------------------------------------------------------------------------------------------------------------------------
* -------------------------------------------------------------------------------------------------------------------------------------
* -------------------------------------------------------------------------------------------------------------------------------------
* -------------------------------------------------------------------------------------------------------------------------------------
*/

/**
 * Provides code actions corresponding to diagnostic problems.
 */
export class Emojinfo implements vscode.CodeActionProvider {
	public static readonly providedCodeActionKinds = [
		vscode.CodeActionKind.QuickFix
	];

	provideCodeActions(document: vscode.TextDocument, range: vscode.Range | vscode.Selection, context: vscode.CodeActionContext, token: vscode.CancellationToken): vscode.CodeAction[] | undefined {
		return context.diagnostics
			.filter(diagnostic => diagnostic.code === EMOJI_MENTION)
			.map(diagnostic => this.createCommandCodeAction(diagnostic));
	}
	private isAVulnerability(document: vscode.TextDocument, range: vscode.Range, i: number) {
		const start = range.start;
		const line = document.lineAt(start.line);
		return line.text.includes(JSON.stringify(diagnosticLibraryAPI[i].vulnName));
	}

	private createCommandCodeAction(diagnostic: vscode.Diagnostic): vscode.CodeAction {
		const action = new vscode.CodeAction('Vulnerability found', vscode.CodeActionKind.QuickFix);
		action.command = { command: COMMAND, title: 'Show vulnerabilities', tooltip: 'This will open the cross site scripting page' };
		action.diagnostics = [diagnostic];
		action.isPreferred = true;
		return action;
	}

	private createFix(document: vscode.TextDocument, range: vscode.Range, solution: string): vscode.CodeAction {
		const fix = new vscode.CodeAction(`Replace with ${solution}`, vscode.CodeActionKind.QuickFix);
		fix.edit = new vscode.WorkspaceEdit();
		fix.edit.replace(document.uri, new vscode.Range(range.start, range.start.translate(0, 2)), solution);
		return fix;
	}
}

/**
 * Analyzes the text document for problems. 
 * This demo diagnostic problem provider finds all mentions of 'emoji'.
 * @param doc text document to analyze
 * @param emojiDiagnostics diagnostic collection
 */
export function refreshDiagnostics(doc: vscode.TextDocument, emojiDiagnostics: vscode.DiagnosticCollection): void {
	const diagnostics: vscode.Diagnostic[] = [];

	for (let lineIndex = 0; lineIndex < doc.lineCount; lineIndex++) {
		const lineOfText = doc.lineAt(lineIndex);
		for (let i = 0; i < diagnosticLibraryAPI.length; i++) {
			if (lineOfText.text.includes(JSON.stringify(diagnosticLibraryAPI[i].vulnName))) {
				diagnostics.push(createDiagnostic(doc, lineOfText, lineIndex, i));
			}
		}
	}
	emojiDiagnostics.set(doc.uri, diagnostics);
}

function createDiagnostic(doc: vscode.TextDocument, lineOfText: vscode.TextLine, lineIndex: number, i: number): vscode.Diagnostic {
	// find where in the line of that the 'emoji' is mentioned
	const index = lineOfText.text.indexOf(JSON.stringify(diagnosticLibraryAPI[i].vulnName));

	console.log("Soy el console log 10000 :D"+ JSON.stringify(diagnosticLibraryAPI[i].vulnName).length);

	// create range that represents, where in the document the word is
	const range = new vscode.Range(lineIndex, index, lineIndex, index + JSON.stringify(diagnosticLibraryAPI[i].vulnName).length);

	const diagnostic = new vscode.Diagnostic(range, JSON.stringify(diagnosticLibraryAPI[i].vulnTitle),
		vscode.DiagnosticSeverity.Warning);

	diagnostic.code = EMOJI_MENTION;
	return diagnostic;
}

export function subscribeToDocumentChanges(context: vscode.ExtensionContext, emojiDiagnostics: vscode.DiagnosticCollection): void {
	if (vscode.window.activeTextEditor) {
		refreshDiagnostics(vscode.window.activeTextEditor.document, emojiDiagnostics);
	}
	context.subscriptions.push(
		vscode.window.onDidChangeActiveTextEditor(editor => {
			if (editor) {
				refreshDiagnostics(editor.document, emojiDiagnostics);
			}
		})
	);

	context.subscriptions.push(
		vscode.workspace.onDidChangeTextDocument(e => refreshDiagnostics(e.document, emojiDiagnostics))
	);

	context.subscriptions.push(
		vscode.workspace.onDidCloseTextDocument(doc => emojiDiagnostics.delete(doc.uri))
	);

}