"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.subscribeToDocumentChanges = exports.refreshDiagnostics = exports.Emojinfo = exports.Emojizer = exports.activate = exports.EMOJI_MENTION = void 0;
const vscode = require("vscode");
//fetch connection to api
const node_fetch_1 = require("node-fetch");
/** Code that is used to associate diagnostic entries with code actions. */
exports.EMOJI_MENTION = 'emoji_mention';
/** String to detect in the text document. */
// eslint-disable-next-line prefer-const
let diagnosticLibrary = [
    { "vulnName": "Cross-Site", "vulnTitle": "Cross-Site vulnerability founded", "vulnSolution": "No cross-site" },
    { "vulnName": "Injection", "vulnTitle": "Injection vulnerability founded", "vulnSolution": "No injection" }
];
let diagnosticLibraryAPI;
// eslint-disable-next-line prefer-const
let solutionsLibrary = [];
const COMMAND = 'code-actions-sample.command';
function activate(context) {
    async function getUsers() {
        try {
            const response = await (0, node_fetch_1.default)('http://127.0.0.1:4000/data', {
                method: 'GET',
                headers: {
                    Accept: 'application/json',
                },
            });
            if (!response.ok) {
                throw new Error(`Error! status: ${response.status}`);
            }
            const result = (await response.json());
            console.log(result);
            console.log('size: ', result.length);
            console.log("Name: ", JSON.stringify(result[0].predictions));
            diagnosticLibraryAPI = result;
            console.log('Size of diagn', JSON.stringify(diagnosticLibraryAPI));
            return result;
        }
        catch (error) {
            if (error instanceof Error) {
                console.log('error message: ', error.message);
                return error.message;
            }
            else {
                console.log('unexpected error: ', error);
                return 'An unexpected error occurred';
            }
        }
    }
    async function getPath() {
        const editor = vscode.window.activeTextEditor;
        const document = editor.document;
        const fileContent = document.getText();
        //const activeEditor = vscode.window.activeTextEditor;
        if (editor) {
            //const filePath = activeEditor.document.getText;
            (0, node_fetch_1.default)('http://127.0.0.1:4000/path', {
                method: 'POST',
                body: JSON.stringify({ fileContent }),
                headers: { 'Content-Type': 'application/json' },
            });
        }
        else {
            console.log('There is no active text editor');
        }
    }
    setInterval(getPath, 60000);
    getUsers();
    context.subscriptions.push(vscode.languages.registerCodeActionsProvider('javascript', new Emojizer(), {
        providedCodeActionKinds: Emojizer.providedCodeActionKinds
    }));
    const emojiDiagnostics = vscode.languages.createDiagnosticCollection("emoji");
    context.subscriptions.push(emojiDiagnostics);
    subscribeToDocumentChanges(context, emojiDiagnostics);
    context.subscriptions.push(vscode.languages.registerCodeActionsProvider('javascript', new Emojinfo(), {
        providedCodeActionKinds: Emojinfo.providedCodeActionKinds
    }));
    context.subscriptions.push(vscode.commands.registerCommand(COMMAND, () => vscode.env.openExternal(vscode.Uri.parse('https://security.snyk.io/vuln/SNYK-JS-SCULLYIOSCULLY-1055829'))));
}
exports.activate = activate;
/**
 * Provides code actions for converting :) to a smiley emoji.
 */
class Emojizer {
    provideCodeActions(document, range) {
        const vulnFindedName = this.whatIsOnLineAPI(document, range);
        //const replaceWithSmileyFix = this.createFix(document, range, JSON.stringify(diagnosticLibraryAPI[vulnFindedName].vulnSolution));
        const replaceWithSmileyFix = this.createFix(document, range, vulnFindedName);
        replaceWithSmileyFix.isPreferred = true;
        return [
            replaceWithSmileyFix,
        ];
    }
    isAtStartOfSmiley(document, range) {
        const start = range.start;
        const line = document.lineAt(start.line);
        return true;
    }
    whatIsOnLineAPI(document, range) {
        const start = range.start;
        const line = document.lineAt(start.line);
        // eslint-disable-next-line prefer-const
        let vulName = JSON.stringify(diagnosticLibraryAPI);
        return vulName;
    }
    createFix(document, range, emoji) {
        if (emoji == undefined) {
            const fix = new vscode.CodeAction(`Not enough information`, vscode.CodeActionKind.QuickFix);
            fix.edit = new vscode.WorkspaceEdit();
            fix.edit.replace(document.uri, new vscode.Range(range.start, range.start.translate(0, 2)), emoji);
            return fix;
        }
        else {
            const fix = new vscode.CodeAction(`Vulnerability found in your code: ${emoji}`, vscode.CodeActionKind.QuickFix);
            fix.edit = new vscode.WorkspaceEdit();
            fix.edit.replace(document.uri, new vscode.Range(range.start, range.start.translate(0, 2)), emoji);
            return fix;
        }
    }
}
exports.Emojizer = Emojizer;
Emojizer.providedCodeActionKinds = [
    vscode.CodeActionKind.QuickFix
];
/*
* -------------------------------------------------------------------------------------------------------------------------------------
* -------------------------------------------------------------------------------------------------------------------------------------
* -------------------------------------------------------------------------------------------------------------------------------------
* -------------------------------------------------------------------------------------------------------------------------------------
* -------------------------------------------------------------------------------------------------------------------------------------
* -------------------------------------------------------------------------------------------------------------------------------------
* -------------------------------------------------------------------------------------------------------------------------------------
* -------------------------------------------------------------------------------------------------------------------------------------
* -------------------------------------------------------------------------------------------------------------------------------------
* -------------------------------------------------------------------------------------------------------------------------------------
*/
/**
 * Provides code actions corresponding to diagnostic problems.
 */
class Emojinfo {
    provideCodeActions(document, range, context, token) {
        return context.diagnostics
            .filter(diagnostic => diagnostic.code === exports.EMOJI_MENTION)
            .map(diagnostic => this.createCommandCodeAction(diagnostic));
    }
    isAVulnerability(document, range, i) {
        const end = range.end;
        const line = document.lineAt(end.line);
        //returnline.text.includes(JSON.stringify(diagnosticLibraryAPI[i].vulnName));
        return true;
    }
    createCommandCodeAction(diagnostic) {
        const action = new vscode.CodeAction('Vulnerability found', vscode.CodeActionKind.QuickFix);
        action.command = { command: COMMAND, title: 'Show vulnerabilities', tooltip: 'This will open the cross site scripting page' };
        action.diagnostics = [diagnostic];
        action.isPreferred = true;
        return action;
    }
    createFix(document, range, solution) {
        const fix = new vscode.CodeAction(`Vulnerability found in your code: ${solution}`, vscode.CodeActionKind.QuickFix);
        fix.edit = new vscode.WorkspaceEdit();
        fix.edit.replace(document.uri, new vscode.Range(range.start, range.start.translate(0, 2)), solution);
        return fix;
    }
}
exports.Emojinfo = Emojinfo;
Emojinfo.providedCodeActionKinds = [
    vscode.CodeActionKind.QuickFix
];
/**
 * Analyzes the text document for problems.
 * This demo diagnostic problem provider finds all mentions of 'emoji'.
 * @param doc text document to analyze
 * @param emojiDiagnostics diagnostic collection
 */
function refreshDiagnostics(doc, emojiDiagnostics) {
    const diagnostics = [];
    const lineIndex1 = doc.lineCount - 1;
    const lineOfText1 = doc.lineAt(doc.lineCount - 1);
    diagnostics.push(createDiagnostic(doc, lineOfText1, lineIndex1, 0));
    /* for (let lineIndex = 0; lineIndex < doc.lineCount; lineIndex++) {
        const lineOfText = doc.lineAt(lineIndex);
        for (let i = 0; i < diagnosticLibraryAPI.length; i++) {
            if (lineOfText.text.includes(JSON.stringify(diagnosticLibraryAPI[i].vulnName))) {
                diagnostics.push(createDiagnostic(doc, lineOfText, lineIndex, i));
            }
        }
    } */
    emojiDiagnostics.set(doc.uri, diagnostics);
}
exports.refreshDiagnostics = refreshDiagnostics;
function createDiagnostic(doc, lineOfText, lineIndex, i) {
    // find where in the line of that the 'emoji' is mentioned
    const index = lineOfText.text.indexOf(JSON.stringify(diagnosticLibraryAPI));
    /* console.log("Soy el console log 10000 :D"+ JSON.stringify(diagnosticLibraryAPI[0].predictions).length); */
    // create range that represents, where in the document the word is
    const range = new vscode.Range(lineIndex, index, lineIndex, index + JSON.stringify(diagnosticLibraryAPI).length);
    const diagnostic = new vscode.Diagnostic(range, JSON.stringify(diagnosticLibraryAPI), vscode.DiagnosticSeverity.Warning);
    diagnostic.code = exports.EMOJI_MENTION;
    return diagnostic;
}
function subscribeToDocumentChanges(context, emojiDiagnostics) {
    if (vscode.window.activeTextEditor) {
        refreshDiagnostics(vscode.window.activeTextEditor.document, emojiDiagnostics);
    }
    context.subscriptions.push(vscode.window.onDidChangeActiveTextEditor(editor => {
        if (editor) {
            refreshDiagnostics(editor.document, emojiDiagnostics);
        }
    }));
    context.subscriptions.push(vscode.workspace.onDidChangeTextDocument(e => refreshDiagnostics(e.document, emojiDiagnostics)));
    context.subscriptions.push(vscode.workspace.onDidCloseTextDocument(doc => emojiDiagnostics.delete(doc.uri)));
}
exports.subscribeToDocumentChanges = subscribeToDocumentChanges;
//# sourceMappingURL=extension.js.map