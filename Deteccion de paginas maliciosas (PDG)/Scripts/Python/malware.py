#!/usr/bin/python
""" Autor: Jose Luis Osorio Quintero
    Universidad Icesi 2017
    Proyecto de grado: Sistema open source para la deteccion paginas web maliciosas
    Este script tiene como funcion la abstracion de caracteristicas
    de un trafico de red obtenido del conjunto de urls.
    Toda las caracteristicas obtenidas para el trafico de red son basadas
    en el articulo Cross-Layer Detection of Malicious Websites"""

import pyshark
import datetime
from cachecontrol import CacheControl
import whois
import requests


def longitud_url(url):
    """ Determina la longitud de la url
    url: es la direccion de la pagina web """
    print "--------------- Obteniendo longitud URL -------------------"
    return len(str(url))


def numero_caracteres_especiales(url):
    """ Cuenta la cantidad de caracteres especiales que hay en la url
    url: es la direccion de la pagina web """
    print "--------------- Obteniendo Numero de caracteres esp -------------------"
    try:
        # cuantas letras hay por linea
        contador_alfabeto = sum(1 for c in url if c.isalpha())
        # cuantos numero hay por linea
        contador_digitos = sum(1 for c in url if c.isdigit())
        caracteres_alfanumericos = contador_digitos + contador_alfabeto
        longitud = len(str(url))  # longitud de la linea
        caracteres_especiales = longitud - caracteres_alfanumericos
    except Exception:
        caracteres_especiales = -1
    return caracteres_especiales


def presencia_direccion_ip(url):
    """ Determina la si la url no tiene un nombre de dominio
    url: es la direccion de la pagina web """
    return url


# https://media.readthedocs.org/pdf/requests-docs-es/latest/requests-docs-es.pdf
def chartset(request):
    """ Conjunto de caracteres que determian la pagina
    request: respuesta de la url"""
    print "--------------- Obteniendo charset -------------------"
    try:
        charset = request.encoding
    except AttributeError as error_atributo:
        charset = "NA"
        print "charset: " + str(error_atributo)
    return charset


def nombre_servidor_web(request):
    """ Nombre del servidor web donde esta alojada la pagina"""
    print "--------------- Obteniendo servidor -------------------"
    try:
        cabecera = request.headers
        server = cabecera.get("server")
    except AttributeError as error_atributo:
        server = "NA"
        print "nombre_servidor_web: " + str(error_atributo)
    return server


def http_header_control_cache(request):
    """ Tipo de control de cache
    url: direccion de la pagina web"""
    print "--------------- Obteniendo cache control -------------------"
    try:
        cabecera = request.headers
        cache_control = cabecera.get("cache-control")
    except Exception:
        cache_control = "NA"
        print "Error inesperado en la %s no se encontro cache_control" % (url)
    return cache_control


def http_header_content_length(request):
    """ longitud del contenido de la cabecera http de la pagina web
    url: direccion de la pagina web"""
    print "--------------- Obteniendo content length -------------------"
    try:
        cabecera = request.headers
        content_length = cabecera.get("content-length")
    except Exception:
        content_length = "NA"
        print "Error inesperado en la %s no se encontro content_length en la cabecera" % (url)
    return content_length


def whois_reg_date(whois):
    """ Fecha en la que fue registrado el sitio"""
    print "--------------- Obteniendo reg date -------------------"
    reg_date = []
    try:
        reg_date = whois.creation_date
        if reg_date != None:
            if isinstance(reg_date, datetime.date):
                reg_date = reg_date
            elif len(reg_date) > 1:
                reg_date = reg_date[0]
    except AttributeError as error_atributo:
        reg_date = "NA"
        print "whois_reg_date: " + str(error_atributo)
    return reg_date


def whois_update_date(whois):
    """ Fecha en la que fue actualizado el sitio
    url: direccion de la pagina web"""
    print "--------------- Obteniendo update date -------------------"
    try:
        update = whois.updated_date
        if update != None:
            if isinstance(update, datetime.date):
                update = update
            elif len(update) > 1:
                update = update[0]
    except AttributeError as error_atributo:
        update = "NA"
        print "whois_update_date: " + str(error_atributo)
    return update

def whois_country(whois):
    """ nombre del pais donde proviene el servicio web
    url: direccion de la pagina web"""
    print "--------------- Obteniendo country -------------------"
    try:
        country = whois.country
    except AttributeError as error_atributo:
        country = "NA"
        print 'whois_country: ' + str(error_atributo)
    return country


def whois_state_prov(whois):
    """ continente donde proviene el sitio web
    url: direccion del sitio web"""
    print "--------------- Obteniendo state prov -------------------"
    try:
        state_prov = whois.state
    except AttributeError as error_atributo:
        state_prov = "NA"
        print "whois_state_prov: " + str(error_atributo)
    return state_prov


def within_domain(whois):
    """ Nombre del dominio de la url
    url: direccion de la pagina web"""
    print "--------------- Obteniendo whitin domain -------------------"
    try:
        domain = whois.domain
    except AttributeError as error_atributo:
        domain = "NA"
        print "within_domain: " + str(error_atributo)

    return domain


def read_file(ruta_archivo):
    """ Lee la ruta del archivo pcap de tcpdump """
    return pyshark.FileCapture(ruta_archivo)


def tcp_conversation_exchange(captura, IP_HONEYPOT):  # N1
    """ cuenta la cantidad de paquetes que hay para el protocolo asignado """
    print "--------------- Obteniendo conversacion tcp -------------------"
    pkts = []
    for pkt in captura:
        try:
            if pkt.transport_layer == 'TCP' and pkt.ip.src == IP_HONEYPOT:
                pkts.append(pkt)
        except AttributeError:
            pass
        except Exception:
            print "Error en tcp_conversartion_exchange"
    return pkts


def dist_remote_tcp_port(captura,IP_HONEYPOT):  # N2
    """ Numero total de puertos distintos a los puertos TCP """
    print "--------------- Obteniendo dist remote tcp port -------------------"
    numero_puertos = 0
    for pkt in captura:
        try:
            if pkt.transport_layer == 'TCP' and pkt.ip.src == IP_HONEYPOT:
                if pkt['TCP'].dstport != '80':
                    numero_puertos = numero_puertos + 1
        except AttributeError:
            pass
        except Exception:
            print 'Error en dist_remote_tcp_port'
    return numero_puertos


def remote_ips(pkts,IP_HONEYPOT):  # N3
    """ Numero distinto de direcciones IP conectadas al honeypot """
    print "--------------- Obteniendo remote ips -------------------"
    numero_ips = []
    for pkt in pkts:
        try:
            if pkt.ip.src == IP_HONEYPOT:
                dst_addr = pkt.ip.dst
                if dst_addr != IP_HONEYPOT:
                    if dst_addr not in numero_ips:
                        numero_ips.append(dst_addr)
        except AttributeError:
            pass
        except Exception:
            print 'Error en remote_ips'
    return numero_ips


def pkt_without_dns(captura,IP_HONEYPOT):
    """ Almacena en un arreglo todo los paquetes que no son DNS"""
    print "--------------- Obteniendo pkt sin dns -------------------"
    pkts_temp = []
    pkts_dns = []
    for pkt in captura:
        try:
            if pkt.ip.src == IP_HONEYPOT:
                for lyr in pkt.layers:
                    if lyr.layer_name in 'dns':
                        if pkt not in pkts_dns:
                            pkts_dns.append(pkt)
                if pkt not in pkts_dns and pkt not in pkts_temp:
                    pkts_temp.append(pkt)
        except AttributeError:
            pass
        except Exception:
            print 'Error en pkt_without_dns'
    return pkts_temp


def app_bytes(pkts,IP_HONEYPOT):  # N4
    """ Numero de bytes de la capa de aplicacion envia por el honeypot
    hacia el sitio web, no se incluyen los datos de los servidores DNS """
    print "--------------- Obteniendo app bytes -------------------"
    tamanio_pkt = 0
    for pkt in pkts:
        try:
            tamanio_pkt = tamanio_pkt + int(pkt.captured_length)
        except AttributeError:
            pass
        except Exception:
            print 'Error en app_bytes'
    return tamanio_pkt


def udp_packets(pkts,IP_HONEYPOT):  # N5
    """ Numero de paquetes UDP, no se incluyen los datos de los DNS """
    print "--------------- Obteniendo udp pkt -------------------"
    pkts_temp = []
    for pkt in pkts:
        try:
            if pkt.ip.src == IP_HONEYPOT:
                for lyr in pkt.layers:
                    if lyr.layer_name in 'udp':
                        if pkt not in pkts_temp:
                            pkts_temp.append(pkt)
        except AttributeError:
            pass
        except Exception:
            print 'Error en udp_packets'
    return pkts_temp


def tcp_urg_packet(captura,IP_HONEYPOT):  # N6
    """ Numero de paquetes TCP con la bandera de URG """
    print "--------------- Obteniendo tcp urg -------------------"
    pkts_temp = []
    for pkt in captura:
        try:
            if pkt.transport_layer == 'TCP' and pkt.ip.src == IP_HONEYPOT:
                for lyr in pkt.layers:
                    flag_urg = str(lyr.get_field_value('tcp.flags.urg'))
                    if flag_urg not in 'None' and flag_urg not in '0' and pkt not in pkts_temp:
                        pkts_temp.append(pkt)
        except AttributeError:
            pass
        except Exception:
            print 'Error en tcp_urg_packet'
    return pkts_temp


def source_app_packets(captura,IP_HONEYPOT):  # N7
    """ Numero de paquetes enviados por el honeypot hacia el servidor remoto """
    print "--------------- Obteniendo source app pkts -------------------"
    pkts = []
    for pkt in captura:
        try:
            if pkt.ip.src == IP_HONEYPOT:
                pkts.append(pkt)
        except AttributeError:
            pass
        except Exception:
            print 'Error en source_app_packets'
    return pkts


def remote_app_packets(captura, IP_HONEYPOT):  # N8
    """ Numero de paquetes enviados por el servidor remoto hacia el honeypot """
    print "--------------- Obteniendo remote pkts -------------------"
    pkts = []
    for pkt in captura:
        try:
            if pkt.ip.dst == IP_HONEYPOT:
                pkts.append(pkt)
        except AttributeError:
            pass
        except Exception:
            print 'Error en remote_app_packets'
    return pkts

def source_app_bytes(captura, IP_HONEYPOT):  # N9
    """ volumen en bytes de la comunicacion de honeypot a servidor web """
    print "--------------- Obteniendo src app bytes -------------------"
    tamanio_pkt = 0
    for pkt in captura:
        try:
            if pkt.ip.dst == IP_HONEYPOT:
                tamanio_pkt = tamanio_pkt + int(pkt.captured_length)
        except AttributeError:
            pass
        except Exception:
            print 'Error en source_app_bytes'
    return tamanio_pkt


def remote_app_bytes(captura,IP_HONEYPOT):  # N10
    """ volumen en bytes de la comunicacion del servidor web al honeypot """
    print "--------------- Obteniendo remote app bytes -------------------"
    tamanio_pkt = 0
    for pkt in captura:
        try:
            if pkt.ip.src == IP_HONEYPOT:
                tamanio_pkt = tamanio_pkt + int(pkt.captured_length)
        except AttributeError:
            pass
        except Exception:
            print 'Error en remote_app_bytes'
    return tamanio_pkt


def paginas_visitadas(captura, IP_HONEYPOT):
    """ cantidad de paginas http encontradas por el sniffer"""
    print "--------------- Obteniendo paginas visitadas -------------------"
    pkts_temp = []
    for pkt in captura:
        try:
            if pkt.ip.src == IP_HONEYPOT:
                for lyr in pkt.layers:
                    if lyr.layer_name in 'http':
                        if pkt not in pkts_temp:
                            pkts_temp.append(pkt)
        except AttributeError:
            pass
        except Exception:
            print 'Error en paginas_visitadas'
    return pkts_temp


def duration(captura, IP_HONEYPOT):  # N11
    """ Tiempo de duracion de la pagina web """
    print "--------------- Obteniendo duraccion -------------------"
    time = 'NA'
    try:
        pkts_http = paginas_visitadas(captura ,IP_HONEYPOT)[0]
        for lyr in pkts_http.layers:
            timestamp = lyr.get_field_value('tcp.options.timestamp.tsval')
            if str(timestamp) not in 'None':
                time = str(timestamp)
    except IndexError:
        pass
    return time


def avg_local_pkt_rate(captura,IP_HONEYPOT):  # N12
    """ promedio de paquetes IP por segundo N9/N11 """
    print "--------------- Obteniendo avg local -------------------"
    time = duration(captura,IP_HONEYPOT)
    if time not in 'NA':
        resultado = len(source_app_packets(captura,IP_HONEYPOT)) / float(time)
    else:
        resultado = 'NA'
    return resultado


def avg_remote_pkt_rate(captura,IP_HONEYPOT):  # N13
    """ promedio de paquetes IP por segundo N10/N11 """
    print "--------------- Obteniendo avg remote -------------------"
    time = duration(captura,IP_HONEYPOT)
    if time not in 'NA':
        resultado = len(remote_app_packets(captura,IP_HONEYPOT)) / float(time)
    else:
        resultado = 'NA'
    return resultado


def app_packets(captura,IP_HONEYPOT):  # N14
    """ numero de paquetes IP incluidos los del servidor DNS """
    print "--------------- Obteniendo app pkts -------------------"
    pkts_temp = []
    for pkt in captura:
        try:
            if pkt.ip.src == IP_HONEYPOT:
                for lyr in pkt.layers:
                    if lyr.layer_name in 'ip':
                        if pkt not in pkts_temp:
                            pkts_temp.append(pkt)
        except AttributeError:
            pass
        except Exception:
            print 'Error en app_packets'
    return pkts_temp


def dns_query_times(captura,IP_HONEYPOT):  # N15
    """ Lista de capas de DNS queries """
    print "--------------- Obteniendo dns query -------------------"
    layers_dns = []
    for pkt in captura:
        try:
            if pkt.ip.src == IP_HONEYPOT:
                for lyr in pkt.layers:
                    if lyr.layer_name in 'dns':
                        layers_dns.append(lyr)
        except AttributeError:
            pass
        except Exception:
            print 'Error en dns_query_times'
    return layers_dns


def dns_response_time():  # N16
    """ tiempo de los servidores DNS """
    return 0


def print_conversation_header(pkt):  # Example
    """ Imprime la cabecera de informacion """
    try:
        protocol = pkt.transport_layer
        src_addr = pkt.ip.src
        src_port = pkt[pkt.transport_layer].srcport
        dst_addr = pkt.ip.dst
        dst_port = pkt[pkt.transport_layer].dstport
        print '%s  %s:%s --> %s:%s' % (protocol, src_addr, src_port, dst_addr, dst_port)
    except AttributeError:
        pass
    except Exception:
        print 'Error en print_conversation_header'


def crear_matriz(ruta_datos, ruta_mtx_trans):
    """ Crea una matriz con las caracteristicas de la capa de transporte
    @param ruta_dataset ruta de los dataset a analizar
    @param ruta_matriz ruta del archivo a crear con la matriz de caracteristicas"""

    with open(name=ruta_datos, mode='r', buffering=1) as dataset:
        with open(name=ruta_mtx_trans, mode='w') as matriz:
            for linea in dataset:
                try:
                    id_url = linea.split(';')[0]
                    url = linea.split(';')[1]
                    IP_HONEYPOT = linea.split(';')[2]
                    file_pcap =  str(linea.split(';')[3]).strip() + '.pcap'
                    print 'Extrayendo  '
                    captura = pyshark.FileCapture(file_pcap)
                    request = requests.get(url)
                    details = whois.whois(url)
                    print "################### ESCRIBIENDO DATOS #############################"
                    print url
                    print "###################################################################"
                    matriz.writelines(id_url + ';'
                                      + str(longitud_url(url)) + ';'
                                      + str(numero_caracteres_especiales(url)) + ';'
                                      + str(chartset(request)) + ';'
                                      + str(nombre_servidor_web(request)) + ';'
                                      + str(http_header_control_cache(request)) + ';'
                                      + str(http_header_content_length(request)) + ';'
                                      + str(whois_country(details)) + ';'
                                      + str(whois_state_prov(details)) + ';'
                                      + str(whois_reg_date(details)) + ';'
                                      + str(whois_update_date(details)) + ';'
                                      + str(within_domain(details)) + ';'
                                      + str(len(tcp_conversation_exchange(captura,IP_HONEYPOT))) + ';'
                                      + str(dist_remote_tcp_port(captura,IP_HONEYPOT)) + ';'
                                      + str(len(remote_ips(pkt_without_dns(captura,IP_HONEYPOT),IP_HONEYPOT))) + ';'
                                      + str(app_bytes(pkt_without_dns(captura,IP_HONEYPOT),IP_HONEYPOT)) + ';'
                                      + str(len(udp_packets(pkt_without_dns(captura,IP_HONEYPOT),IP_HONEYPOT))) + ';'
                                      + str(len(tcp_urg_packet(captura,IP_HONEYPOT))) + ';'
                                      + str(len(source_app_packets(captura, IP_HONEYPOT))) + ';'
                                      + str(len(remote_app_packets(captura, IP_HONEYPOT))) + ';'
                                      + str(source_app_bytes(captura, IP_HONEYPOT)) + ';'
                                      + str(remote_app_bytes(captura, IP_HONEYPOT)) + ';'
                                      + str(duration(captura, IP_HONEYPOT)) + ';'
                                      + str(avg_local_pkt_rate(captura,IP_HONEYPOT)) + ';'
                                      + str(avg_remote_pkt_rate(captura, IP_HONEYPOT)) + ';'
                                      + str(len(app_packets(captura,IP_HONEYPOT))) + ';'
                                      + str(len(dns_query_times(captura,IP_HONEYPOT))) + '\n')
                except Exception, e:
                    print e



ruta_dataset = '../Malware/malware.csv'
ruta_matriz = '../Malware/resutados_malware.csv'
crear_matriz(ruta_dataset, ruta_matriz)